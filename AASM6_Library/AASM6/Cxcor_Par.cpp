#include "AASM6.h"
#include "Extensions.h"

namespace AASM6
{
	//возвращает с_x_корм при eta_корм = 0
	float Cxcor_Par_1(float M, float lambda_cor, InputComplex& x_2, InputComplex& x_1)
	{
		//1.1: lambda_korm = 2, 1.2: lambda_korm = 3
		static unsigned int Length_1_1 = 36; static float Matrix_1_1[][2] = { {0.6f,0.0590761037735384f}, {0.65f,0.0620480978883868f}, {0.7f,0.0668650209618531f}, {0.8f,0.0785010842010934f}, {0.85f,0.0880038691798063f}, {0.9f,0.0999502274387596f}, {0.95f,0.116667371625802f}, {1.0f,0.138659531147966f}, {1.025f,0.153717101082117f}, {1.05f,0.161804664395692f}, {1.1f,0.166153428893437f}, {1.15f,0.167571898040479f}, {1.2f,0.167587485613523f}, {1.25f,0.166901632399569f}, {1.3f,0.165077886353373f}, {1.35f,0.162661812531488f}, {1.4f,0.15955988549565f}, {1.5f,0.153091042682218f}, {1.6f,0.146715725307053f}, {1.8f,0.134557418332411f}, {2.0f,0.124098156819609f}, {2.125f,0.117383866484322f}, {2.25f,0.111392266563167f}, {2.375f,0.105671558374286f}, {2.5f,0.099921831027724f}, {2.625f,0.0948140449267133f}, {2.75f,0.0898272938555849f}, {2.875f,0.0851618343972366f}, {3.0f,0.0807179410370065f}, {3.5f,0.0687190217853424f}, {4.0f,0.0602926089214686f}, {4.5f,0.0548490776820024f}, {4.75f,0.0526042087108346f}, {5.0f,0.0505084932841143f}, {5.25f,0.0487767705367717f}, {5.5f,0.0475744916867058f} };
		static unsigned int Length_1_2 = 36; static float Matrix_1_2[][2] = { {0.6f,0.055691264022729f}, {0.65f,0.0573748962872895f}, {0.7f,0.06f}, {0.8f,0.0670039246964333f}, {0.85f,0.0725894714820651f}, {0.9f,0.079032334751073f}, {0.95f,0.0883718885623969f}, {1.0f,0.1f}, {1.025f,0.10545970302419f}, {1.05f,0.110700962442968f}, {1.1f,0.120015509087951f}, {1.15f,0.124088131059853f}, {1.2f,0.125574961303564f}, {1.25f,0.125690351522823f}, {1.3f,0.124403416171091f}, {1.35f,0.121950384467789f}, {1.4f,0.118827039872671f}, {1.5f,0.113215513799664f}, {1.6f,0.10800666668097f}, {1.8f,0.0992906157666473f}, {2.0f,0.0922370130596655f}, {2.125f,0.0890465754786965f}, {2.25f,0.086018846378323f}, {2.375f,0.0831095200919306f}, {2.5f,0.0803524259949424f}, {2.625f,0.0777212719075306f}, {2.75f,0.0750277003349232f}, {2.875f,0.0726798837974113f}, {3.0f,0.07f}, {3.5f,0.063089784779771f}, {4.0f,0.0572163818757833f}, {4.5f,0.0525722958586767f}, {4.75f,0.0506600251457505f}, {5.0f,0.0489526405806378f}, {5.25f,0.0476282293360527f}, {5.5f,0.0469420699088544f} };

		//Значения по комплексу x2
		const float x2_arg[3] = { 2.0f, 3.0f };

		//Входной комплекс x1
		const float x1_min = 0.6f;
		const float x1_max = 5.5f;

		//Входной комплекс x2
		float x2 = lambda_cor;

		float x2_min = x2_arg[0];
		float x2_max = x2_arg[1];

		x_2.Min = x2_min;
		x_2.Value = x2;
		x_2.Max = x2_max;

		//Ограничение по диапазону x2
		if (x2 < x2_arg[0])
			x2 = x2_arg[0];
		else if (x2 > x2_arg[1])
			x2 = x2_arg[1];

		//Координата по оси х графика
		float x1 = M;

		x_1.Min = x1_min;
		x_1.Value = x1;
		x_1.Max = x1_max;

		//Ограничение по диапазону оси x
		if (x1 < x1_min)
			x1 = x1_min;
		else if (x1 > x1_max)
			x1 = x1_max;

		//Вычисление
		if (x2 == x2_arg[0])
		{
			float y = Linterp(Matrix_1_1, Length_1_1, x1);

			return y;
		}
		else if (x2_arg[0] <= x2 && x2 < x2_arg[1])
		{
			float y1 = Linterp(Matrix_1_1, Length_1_1, x1);
			float y2 = Linterp(Matrix_1_2, Length_1_2, x1);

			return LinterpOnce(x2_arg[0], y1, x2_arg[1], y2, x2);
		}
		else if (x2 == x2_arg[1])
		{
			float y = Linterp(Matrix_1_2, Length_1_2, x1);

			return y;
		}
		else
			return NAN;
	}

	//возвращает с_x_корм при eta_корм = 0.5
	float Cxcor_Par_2(float M, float lambda_cor, InputComplex& x_2, InputComplex& x_1)
	{
		//1.1: lambda_korm = 1.5, 1.2: lambda_korm = 2.0, 1.3: lambda_korm = 2.5,
		static unsigned int Length_2_1 = 37; static float Matrix_2_1[][2] = { {0.6f,0.0542520745335896f}, {0.65f,0.0560360343222467f}, {0.7f,0.0585885473914241f}, {0.75f,0.0632211775612687f}, {0.8f,0.0693475272098925f}, {0.85f,0.0779656896155023f}, {0.9f,0.0894570868576961f}, {0.95f,0.10001246528267f}, {1.0f,0.112206264623027f}, {1.025f,0.119422070974249f}, {1.05f,0.124628412265637f}, {1.1f,0.130748146766041f}, {1.15f,0.134995425187963f}, {1.2f,0.13768885665608f}, {1.25f,0.138719595397547f}, {1.3f,0.139221750169031f}, {1.35f,0.139116033375034f}, {1.4f,0.137926719442572f}, {1.5f,0.133659806876233f}, {1.6f,0.128143747758431f}, {1.8f,0.116833216444327f}, {2.0f,0.105731494939098f}, {2.125f,0.0999624943875459f}, {2.25f,0.0942216495286345f}, {2.375f,0.0889662556989382f}, {2.5f,0.0837890641897361f}, {2.625f,0.0790493773708077f}, {2.75f,0.0743625615712355f}, {2.875f,0.069858612824662f}, {3.0f,0.0656922140871692f}, {3.5f,0.052397989588745f}, {4.0f,0.0429667465545227f}, {4.5f,0.0356236016090581f}, {4.75f,0.0328046691892352f}, {5.0f,0.0304207572045701f}, {5.25f,0.0288546836380018f}, {5.5f,0.0280194444024987f} };
		static unsigned int Length_2_2 = 35; static float Matrix_2_2[][2] = { {0.6f,0.05f}, {0.7f,0.0517896161985129f}, {0.8f,0.0552262774996994f}, {0.85f,0.0579524054516954f}, {0.9f,0.0620996001020723f}, {0.95f,0.0690599267880195f}, {1.0f,0.0784708684946439f}, {1.025f,0.0826875944738796f}, {1.05f,0.086667056311093f}, {1.1f,0.0929715490903673f}, {1.15f,0.0979044287141645f}, {1.2f,0.100990425459802f}, {1.25f,0.103223530271544f}, {1.3f,0.103890561578947f}, {1.35f,0.104035568384904f}, {1.4f,0.103673051370011f}, {1.5f,0.101193434988142f}, {1.6f,0.0970317396571698f}, {1.8f,0.0883023299385444f}, {2.0f,0.0795584195393232f}, {2.125f,0.0755951272429948f}, {2.25f,0.0718212035936461f}, {2.375f,0.0680458769336382f}, {2.5f,0.0644487103585794f}, {2.625f,0.0611068783925555f}, {2.75f,0.0577812723397872f}, {2.875f,0.0545805221391837f}, {3.0f,0.0514561005448113f}, {3.5f,0.0415521356979322f}, {4.0f,0.0341857899553048f}, {4.5f,0.0287190333707171f}, {4.75f,0.0265721904698518f}, {5.0f,0.0249923584576162f}, {5.25f,0.0235814253346685f}, {5.5f,0.0230083949417382f} };
		static unsigned int Length_2_3 = 35; static float Matrix_2_3[][2] = { {0.6f,0.0462290648992918f}, {0.7f,0.0464137805597008f}, {0.8f,0.0476211371480077f}, {0.85f,0.0487696081019907f}, {0.9f,0.05f}, {0.95f,0.0531500759631105f}, {1.0f,0.0569936943235365f}, {1.025f,0.0595306150957612f}, {1.05f,0.0622591809024879f}, {1.1f,0.0675246674814394f}, {1.15f,0.0720408245766809f}, {1.2f,0.0754798088217298f}, {1.25f,0.0779361794620276f}, {1.3f,0.0793512358996781f}, {1.35f,0.0796478350606103f}, {1.4f,0.0791732546600138f}, {1.5f,0.0768531122394901f}, {1.6f,0.0735481019283048f}, {1.8f,0.0671810230064489f}, {2.0f,0.06f}, {2.125f,0.0576863856208335f}, {2.25f,0.054971256481424f}, {2.375f,0.0521774432001309f}, {2.5f,0.0496729029163968f}, {2.625f,0.0471391341837468f}, {2.75f,0.0448108740957374f}, {2.875f,0.0425991325548139f}, {3.0f,0.04f}, {3.5f,0.0334044746583546f}, {4.0f,0.0281370648288519f}, {4.5f,0.0244074667994043f}, {4.75f,0.0229643046428913f}, {5.0f,0.0217423576832675f}, {5.25f,0.0204107401072704f}, {5.5f,0.02f} };

		//Значения по комплексу x2
		const float x2_arg[3] = { 1.5f, 2.0f, 2.5f };

		//Входной комплекс x1
		const float x1_min = 0.6f;
		const float x1_max = 5.5f;

		//Входной комплекс x2
		float x2 = lambda_cor;

		float x2_min = x2_arg[0];
		float x2_max = x2_arg[2];

		x_2.Min = x2_min;
		x_2.Value = x2;
		x_2.Max = x2_max;

		//Ограничение по диапазону x2
		if (x2 < x2_arg[0])
			x2 = x2_arg[0];
		else if (x2 > x2_arg[2])
			x2 = x2_arg[2];

		//Координата по оси х графика
		float x1 = M;

		x_1.Min = x1_min;
		x_1.Value = x1;
		x_1.Max = x1_max;

		//Ограничение по диапазону оси x
		if (x1 < x1_min)
			x1 = x1_min;
		else if (x1 > x1_max)
			x1 = x1_max;

		//Вычисление
		if (x2 == x2_arg[0])
		{
			float y = Linterp(Matrix_2_1, Length_2_1, x1);

			return y;
		}
		else if (x2_arg[0] <= x2 && x2 < x2_arg[1])
		{
			float y1 = Linterp(Matrix_2_1, Length_2_1, x1);
			float y2 = Linterp(Matrix_2_2, Length_2_2, x1);

			return LinterpOnce(x2_arg[0], y1, x2_arg[1], y2, x2);
		}
		else if (x2_arg[1] <= x2 && x2 < x2_arg[2])
		{
			float y1 = Linterp(Matrix_2_2, Length_2_2, x1);
			float y2 = Linterp(Matrix_2_3, Length_2_3, x1);

			return LinterpOnce(x2_arg[1], y1, x2_arg[2], y2, x2);
		}
		else if (x2 == x2_arg[2])
		{
			float y = Linterp(Matrix_2_3, Length_2_3, x1);

			return y;
		}
		else
			return NAN;
	}

	//возвращает с_x_корм при eta_корм = 0.75
	float Cxcor_Par_3(float M, float lambda_cor, InputComplex& x_2, InputComplex& x_1)
	{
		//3.1: lambda_korm = 1, 3.2: lambda_korm = 1.5, 3.3: lambda_korm = 2,
		static unsigned int Length_3_1 = 37; static float Matrix_3_1[][2] = { {0.6f,0.0414127380555039f}, {0.65f,0.0416639257517001f}, {0.7f,0.0424470433623302f}, {0.75f,0.0432635890672929f}, {0.8f,0.0448220453982348f}, {0.85f,0.0464661933673078f}, {0.9f,0.049239214330301f}, {0.95f,0.0534805628949964f}, {1.0f,0.0592073607265897f}, {1.025f,0.0627537743478859f}, {1.05f,0.0661920838399821f}, {1.1f,0.0711467008175769f}, {1.15f,0.0751608612214383f}, {1.2f,0.0788953834848059f}, {1.25f,0.0821518147337811f}, {1.3f,0.0845963933168068f}, {1.35f,0.0862200986487058f}, {1.4f,0.0869237042925286f}, {1.5f,0.0858476639588902f}, {1.6f,0.082366439450636f}, {1.8f,0.0741180157090634f}, {2.0f,0.0658566023238033f}, {2.125f,0.0621078599221995f}, {2.25f,0.0584702470195004f}, {2.375f,0.0549864635181593f}, {2.5f,0.0515809839112233f}, {2.625f,0.0486408008616754f}, {2.75f,0.0457717230588607f}, {2.875f,0.0430684093814724f}, {3.0f,0.0403650957040841f}, {3.5f,0.0320556311629848f}, {4.0f,0.0254049335949767f}, {4.5f,0.0202610346947204f}, {4.75f,0.0181567124173428f}, {5.0f,0.0165719758874659f}, {5.25f,0.0152600218750268f}, {5.5f,0.0146495086217135f} };
		static unsigned int Length_3_2 = 35; static float Matrix_3_2[][2] = { {0.6f,0.0352613438253407f}, {0.7f,0.0352094397572144f}, {0.8f,0.0355101259178401f}, {0.85f,0.0362017040872792f}, {0.9f,0.0372240370334066f}, {0.95f,0.0385470561401596f}, {1.0f,0.0405616534163517f}, {1.025f,0.0418771553690891f}, {1.05f,0.0431926573218265f}, {1.1f,0.0458236612273013f}, {1.15f,0.0480487388159314f}, {1.2f,0.049612306851185f}, {1.25f,0.0507549142615626f}, {1.3f,0.0516269041273771f}, {1.35f,0.0518674530558777f}, {1.4f,0.0516391062130068f}, {1.5f,0.0502036944148101f}, {1.6f,0.0475518097367114f}, {1.8f,0.0425612551062737f}, {2.0f,0.037173961823207f}, {2.125f,0.0351824125289249f}, {2.25f,0.0332055686263362f}, {2.375f,0.0312863912431055f}, {2.5f,0.0294688795695186f}, {2.625f,0.0276391726852205f}, {2.75f,0.0259152294603961f}, {2.875f,0.024332854836362f}, {3.0f,0.0228287273834132f}, {3.5f,0.0180261015884313f}, {4.0f,0.0144972156782054f}, {4.5f,0.0124717604516261f}, {4.75f,0.0111144966400008f}, {5.0f,0.01f}, {5.25f,0.00969458988322353f}, {5.5f,0.00940225613918116f} };
		static unsigned int Length_3_3 = 39; static float Matrix_3_3[][2] = { {0.6f,0.03f}, {0.7f,0.03f}, {0.8f,0.0304226050475326f}, {0.85f,0.0305628932049323f}, {0.9f,0.0309694890225373f}, {0.95f,0.0313734470032418f}, {1.0f,0.0318254866215298f}, {1.025f,0.0321612834740701f}, {1.05f,0.0325347211950506f}, {1.1f,0.0332439557685714f}, {1.15f,0.0337271705329483f}, {1.2f,0.0340077468477477f}, {1.25f,0.0339921592747033f}, {1.3f,0.0339609841286145f}, {1.35f,0.0335401196564153f}, {1.4f,0.0331036676111717f}, {1.45f,0.0325752762485051f}, {1.5f,0.0320125374980628f}, {1.55f,0.0312596720179573f}, {1.6f,0.0305473056318879f}, {1.7f,0.0289116950852258f}, {1.8f,0.0272427401464722f}, {1.9f,0.0252855441995844f}, {2.0f,0.0231432084357915f}, {2.125f,0.0218505740099133f}, {2.25f,0.0206715561200867f}, {2.375f,0.0195020523986588f}, {2.5f,0.0183422359381121f}, {2.625f,0.0173532949213282f}, {2.75f,0.0164438068714929f}, {2.875f,0.0155746560237645f}, {3.0f,0.0148038568570302f}, {3.5f,0.0122786700238352f}, {4.0f,0.0105172742698165f}, {4.5f,0.00917674298799693f}, {4.75f,0.00852206492013156f}, {5.0f,0.00805443772879915f}, {5.25f,0.00778944898704412f}, {5.5f,0.00755563539137792f} };

		//Значения по комплексу x2
		const float x2_arg[3] = { 1.0f, 1.5f, 2.0f };

		//Входной комплекс x1
		const float x1_min = 0.6f;
		const float x1_max = 5.5f;

		//Входной комплекс x2
		float x2 = lambda_cor;
		float x2_min = x2_arg[0];
		float x2_max = x2_arg[2];

		x_2.Min = x2_min;
		x_2.Value = x2;
		x_2.Max = x2_max;

		//Ограничение по диапазону x2
		if (x2 < x2_arg[0])
			x2 = x2_arg[0];
		else if (x2 > x2_arg[2])
			x2 = x2_arg[2];

		//Координата по оси х графика
		float x1 = M;

		x_1.Min = x1_min;
		x_1.Value = x1;
		x_1.Max = x1_max;

		//Ограничение по диапазону оси x
		if (x1 < x1_min)
			x1 = x1_min;
		else if (x1 > x1_max)
			x1 = x1_max;

		//Вычисление
		if (x2 == x2_arg[0])
		{
			float y = Linterp(Matrix_3_1, Length_3_1, x1);

			return y;
		}
		else if (x2_arg[0] <= x2 && x2 < x2_arg[1])
		{
			float y1 = Linterp(Matrix_3_1, Length_3_1, x1);
			float y2 = Linterp(Matrix_3_2, Length_3_2, x1);

			return LinterpOnce(x2_arg[0], y1, x2_arg[1], y2, x2);
		}
		else if (x2_arg[1] <= x2 && x2 < x2_arg[2])
		{
			float y1 = Linterp(Matrix_3_2, Length_3_2, x1);
			float y2 = Linterp(Matrix_3_3, Length_3_3, x1);

			return LinterpOnce(x2_arg[1], y1, x2_arg[2], y2, x2);
		}
		else if (x2 == x2_arg[2])
		{
			float y = Linterp(Matrix_3_3, Length_3_3, x1);

			return y;
		}
		else
			return NAN;
	}

	float Cxcor_Par(float M, float lambda_cor, float eta_cor, InputComplex& x_3, InputComplex& x_2, InputComplex& x_1)
	{
		//Значения по комплексу x3
		const float x3_arg[4] = { 0.0f, 0.5f, 0.75f, 1.0f };

		//Входной комплекс x3
		float x3 = eta_cor;

		float x3_min = x3_arg[0];
		float x3_max = x3_arg[3];

		x_3.Min = x3_min;
		x_3.Value = x3;
		x_3.Max = x3_max;

		//Ограничение по диапазону x3
		if (x3 < x3_min)
			x3 = x3_min;
		else if (x3 > x3_max)
			x3 = x3_max;

		//Вычисление
		if (x3 == x3_arg[0])
		{
			//Используем 1-ый график
			float y = Cxcor_Par_1(M, lambda_cor, x_2, x_1);

			return y;
		}
		else if (x3_arg[0] <= x3 && x3 < x3_arg[1])
		{
			//Интерполяция между 1-м и 2-м графиком
			float y1 = Cxcor_Par_1(M, lambda_cor, x_2, x_1);
			float y2 = Cxcor_Par_2(M, lambda_cor, x_2, x_1);

			return LinterpOnce(x3_arg[0], y1, x3_arg[1], y2, x3);
		}
		else if (x3_arg[1] <= x3 && x3 < x3_arg[2])
		{
			//Интерполяция между 2-м и 3-м графиком
			float y1 = Cxcor_Par_2(M, lambda_cor, x_2, x_1);
			float y2 = Cxcor_Par_3(M, lambda_cor, x_2, x_1);

			return LinterpOnce(x3_arg[1], y1, x3_arg[2], y2, x3);
		}
		else if (x3_arg[2] <= x3 && x3 <= x3_arg[3])
		{
			//Интерполяция между 2-м и 3-м графиком
			float y1 = Cxcor_Par_3(M, lambda_cor, x_2, x_1);
			float y2 = 0.0f;

			return LinterpOnce(x3_arg[2], y1, x3_arg[3], y2, x3);
		}		
		else
			return NAN;
	}

	ErrorCode* get_Cxcor_Par(float& Result, float M, float lambda_cor, float eta_cor, InputComplex& x_3, InputComplex& x_2, InputComplex& x_1)
	{
		static ErrorCode ErrC;
		// Проверка: некоторые аргументы не должны быть меньше 0		
		if (M < 0.0f)
		{
			ErrC.ArgNumber = 1;
			ErrC.Code = ErrC_NumberMustNotBeNeg;
			return &ErrC;
		}
		if (lambda_cor < 0.0f)
		{
			ErrC.ArgNumber = 2;
			ErrC.Code = ErrC_NumberMustNotBeNeg;
			return &ErrC;
		}
		if (eta_cor < 0.0f)
		{
			ErrC.ArgNumber = 3;
			ErrC.Code = ErrC_NumberMustNotBeNeg;
			return &ErrC;
		}

		// Вызываем функцию интерполяции графика
		Result = Cxcor_Par(M, lambda_cor, eta_cor, x_3, x_2, x_1);
		ErrC.ArgNumber = ErrC_OK;
		ErrC.Code = ErrC_OK;

		return &ErrC;
	}
}