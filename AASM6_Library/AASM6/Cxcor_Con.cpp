#include "AASM6.h"
#include "Extensions.h"

namespace AASM6
{
	//возвращает с_x_корм при eta_корм = 0
	float Cxcor_Con_1(float M, float lambda_cor, InputComplex& x_2, InputComplex& x_1)
	{
		//1.1: lambda_korm = 2, 1.2: lambda_korm = 3
		static unsigned int Length_1_1 = 38; static float Matrix_1_1[][2] = { {0.6f,0.0706406210408848f}, {0.65f,0.0721035930308065f}, {0.7f,0.0748477639156771f}, {0.8f,0.0839340590220422f}, {0.9f,0.0992269942343103f}, {0.95f,0.111191406176804f}, {1.0f,0.127266512472227f}, {1.025f,0.139099189424786f}, {1.05f,0.142067267616885f}, {1.075f,0.143676132431294f}, {1.1f,0.144577651508333f}, {1.125f,0.14507695438177f}, {1.15f,0.145035345808984f}, {1.175f,0.144563781984071f}, {1.2f,0.143800958149653f}, {1.25f,0.141332182830991f}, {1.3f,0.137559672231688f}, {1.35f,0.13356524924419f}, {1.4f,0.129667912926527f}, {1.5f,0.122594455552834f}, {1.6f,0.116644429644374f}, {1.7f,0.111387879949021f}, {1.8f,0.106949632185134f}, {1.9f,0.103091228422019f}, {2.0f,0.0999732614812755f}, {2.125f,0.0953269708534569f}, {2.25f,0.0913048088174349f}, {2.5f,0.0846454826248894f}, {2.75f,0.0793309483665476f}, {3.0f,0.0749450714034379f}, {3.25f,0.0709621639719695f}, {3.5f,0.067824666620509f}, {3.75f,0.0650127586168416f}, {4.0f,0.0624376428661145f}, {4.25f,0.0604841067793561f}, {4.5f,0.0588265610087732f}, {5.0f,0.0564586384793691f}, {5.5f,0.0555706675308425f} };
		static unsigned int Length_1_2 = 38; static float Matrix_1_2[][2] = { {0.6f,0.063416690415262f}, {0.65f,0.0645677238741557f}, {0.7f,0.0667375601609539f}, {0.8f,0.0739970367322528f}, {0.9f,0.085109566840704f}, {0.95f,0.0927802467547587f}, {1.0f,0.102177526740023f}, {1.025f,0.105900247389932f}, {1.05f,0.107353633400336f}, {1.075f,0.108166352124117f}, {1.1f,0.108452099765547f}, {1.125f,0.108383063414879f}, {1.15f,0.108036014021149f}, {1.175f,0.107540297284138f}, {1.2f,0.106538105341315f}, {1.25f,0.104574180627756f}, {1.3f,0.102061022731592f}, {1.35f,0.0995478648354273f}, {1.4f,0.0973176452454534f}, {1.5f,0.093006996933489f}, {1.6f,0.0891790080850264f}, {1.7f,0.0858836089893934f}, {1.8f,0.0830875127870381f}, {1.9f,0.0805540170843445f}, {2.0f,0.0784078532675452f}, {2.125f,0.0758209951910662f}, {2.25f,0.0731480167216725f}, {2.5f,0.0690565072269217f}, {2.75f,0.065808727091258f}, {3.0f,0.0632890969504227f}, {3.25f,0.0613318658162603f}, {3.5f,0.0596189592342722f}, {3.75f,0.0578584719138956f}, {4.0f,0.056526211239016f}, {4.25f,0.0554794349944678f}, {4.5f,0.0546705624418623f}, {5.0f,0.0537924127687795f}, {5.5f,0.0534593476000596f} };

		//Значения по комплексу x2
		const float x2_arg[3] = { 2.0f, 3.0f };

		//Входной комплекс x1
		const float x1_min = 0.6f;
		const float x1_max = 5.5f;

		//Входной комплекс x2
		float x2 = lambda_cor;
		float x2_min = x2_arg[0];
		float x2_max = x2_arg[1];

		x_2.Min = x2_min;
		x_2.Value = x2;
		x_2.Max = x2_max;

		//Ограничение по диапазону x2
		if (x2 < x2_arg[0])
			x2 = x2_arg[0];
		else if (x2 > x2_arg[1])
			x2 = x2_arg[1];

		//Координата по оси х графика
		float x1 = M;

		x_1.Min = x1_min;
		x_1.Value = x1;
		x_1.Max = x1_max;

		//Ограничение по диапазону оси x
		if (x1 < x1_min)
			x1 = x1_min;
		else if (x1 > x1_max)
			x1 = x1_max;

		//Вычисление
		if (x2 == x2_arg[0])
		{
			float y = Linterp(Matrix_1_1, Length_1_1, x1);

			return y;
		}
		else if (x2_arg[0] <= x2 && x2 < x2_arg[1])
		{
			float y1 = Linterp(Matrix_1_1, Length_1_1, x1);
			float y2 = Linterp(Matrix_1_2, Length_1_2, x1);

			return LinterpOnce(x2_arg[0], y1, x2_arg[1], y2, x2);
		}
		else if (x2 == x2_arg[1])
		{
			float y = Linterp(Matrix_1_2, Length_1_2, x1);

			return y;
		}
		else
			return NAN;
	}

	//возвращает с_x_корм при eta_корм = 0.5
	float Cxcor_Con_2(float M, float lambda_cor, InputComplex& x_2, InputComplex& x_1)
	{
		//1.1: lambda_korm = 1.5, 1.2: lambda_korm = 2.0, 1.3: lambda_korm = 2.5,
		static unsigned int Length_2_1 = 38; static float Matrix_2_1[][2] = { {0.6f,0.0622441418018386f}, {0.65f,0.0632505087661088f}, {0.7f,0.0652632426946492f}, {0.8f,0.0715522159926454f}, {0.9f,0.0819270078388895f}, {0.95f,0.0889386477378263f}, {1.0f,0.0983021422165695f}, {1.025f,0.101970320312058f}, {1.05f,0.104460874389152f}, {1.075f,0.106777957037992f}, {1.1f,0.10821529172925f}, {1.125f,0.108772878462928f}, {1.15f,0.109033085605311f}, {1.175f,0.109132212135743f}, {1.2f,0.109057867237919f}, {1.25f,0.108791274585731f}, {1.3f,0.107970506848529f}, {1.35f,0.106382499704811f}, {1.4f,0.104282622669696f}, {1.5f,0.0999567278476967f}, {1.6f,0.0958245051933834f}, {1.7f,0.0917485662767162f}, {1.8f,0.0876976331202739f}, {1.9f,0.0837728978884524f}, {2.0f,0.0798481635130918f}, {2.125f,0.0758209951910662f}, {2.25f,0.0717106159205762f}, {2.5f,0.0642679514109501f}, {2.75f,0.0583504744753965f}, {3.0f,0.0528357246828332f}, {3.25f,0.0480034463783211f}, {3.5f,0.0435862477201336f}, {3.75f,0.039905196749687f}, {4.0f,0.0364290976128677f}, {4.25f,0.033476214797458f}, {4.5f,0.03f}, {5.0f,0.0264102499187623f}, {5.5f,0.0231975453077897f} };
		static unsigned int Length_2_2 = 37; static float Matrix_2_2[][2] = { {0.6f,0.06f}, {0.7f,0.0605140013053724f}, {0.8f,0.061789516104502f}, {0.9f,0.0642440270573766f}, {0.95f,0.0658759116110999f}, {1.0f,0.0679659388800653f}, {1.025f,0.0690903126393121f}, {1.05f,0.070521895355311f}, {1.075f,0.0719329725941229f}, {1.1f,0.0733599338429067f}, {1.125f,0.0745318512803327f}, {1.15f,0.0754969394839803f}, {1.175f,0.0760525743756217f}, {1.2f,0.0763178627951995f}, {1.25f,0.0764424595802041f}, {1.3f,0.0760325418675302f}, {1.35f,0.0752474201593197f}, {1.4f,0.0739839918408706f}, {1.5f,0.0706225517075827f}, {1.6f,0.0670990725256003f}, {1.7f,0.063467457630903f}, {1.8f,0.0600391128887553f}, {1.9f,0.05649254930713f}, {2.0f,0.0529263249273739f}, {2.125f,0.05f}, {2.25f,0.0485597584996077f}, {2.5f,0.0446858354247112f}, {2.75f,0.0415036787617081f}, {3.0f,0.0385644250783998f}, {3.25f,0.0358574648155524f}, {3.5f,0.0334232405718572f}, {3.75f,0.0309696397647235f}, {4.0f,0.0287921735941739f}, {4.25f,0.0267403063224817f}, {4.5f,0.0247612448857368f}, {5.0f,0.0211604152702595f}, {5.5f,0.0178896617028676f} };
		static unsigned int Length_2_3 = 37; static float Matrix_2_3[][2] = { {0.6f,0.0527434357809699f}, {0.7f,0.0527924379993726f}, {0.8f,0.0530936753435344f}, {0.9f,0.0533790594915826f}, {0.95f,0.0535554655820581f}, {1.0f,0.0537964293849021f}, {1.025f,0.0538959018251675f}, {1.05f,0.0539953742654329f}, {1.075f,0.0541338860787151f}, {1.1f,0.0542907882957206f}, {1.125f,0.0544072915667706f}, {1.15f,0.0545471853786118f}, {1.175f,0.0545677614339974f}, {1.2f,0.0545438408530201f}, {1.25f,0.0543592349386673f}, {1.3f,0.0539819967658593f}, {1.35f,0.0534442317110054f}, {1.4f,0.0527619924623102f}, {1.5f,0.0509159333187819f}, {1.6f,0.0488258730477838f}, {1.7f,0.046273495521831f}, {1.8f,0.0438655921954605f}, {1.9f,0.0419862683562913f}, {2.0f,0.04f}, {2.125f,0.0382727499635283f}, {2.25f,0.0366202815069078f}, {2.5f,0.0333936549421391f}, {2.75f,0.0308036068490839f}, {3.0f,0.0285960409917466f}, {3.25f,0.0265502862443712f}, {3.5f,0.0247588060983645f}, {3.75f,0.0230019997616354f}, {4.0f,0.0216034894541076f}, {4.25f,0.02f}, {4.5f,0.0188642585211812f}, {5.0f,0.0168069458373799f}, {5.5f,0.0150732553735025f} };

		//Значения по комплексу x2
		const float x2_arg[3] = { 1.5f, 2.0f, 2.5f };

		//Входной комплекс x1
		const float x1_min = 0.6f;
		const float x1_max = 5.5f;

		//Входной комплекс x2
		float x2 = lambda_cor;

		float x2_min = x2_arg[0];
		float x2_max = x2_arg[2];

		x_2.Min = x2_min;
		x_2.Value = x2;
		x_2.Max = x2_max;

		//Ограничение по диапазону x2
		if (x2 < x2_arg[0])
			x2 = x2_arg[0];
		else if (x2 > x2_arg[2])
			x2 = x2_arg[2];

		//Координата по оси х графика
		float x1 = M;

		x_1.Min = x1_min;
		x_1.Value = x1;
		x_1.Max = x1_max;

		//Ограничение по диапазону оси x
		if (x1 < x1_min)
			x1 = x1_min;
		else if (x1 > x1_max)
			x1 = x1_max;

		//Вычисление
		if (x2 == x2_arg[0])
		{
			float y = Linterp(Matrix_2_1, Length_2_1, x1);

			return y;
		}
		else if (x2_arg[0] <= x2 && x2 < x2_arg[1])
		{
			float y1 = Linterp(Matrix_2_1, Length_2_1, x1);
			float y2 = Linterp(Matrix_2_2, Length_2_2, x1);

			return LinterpOnce(x2_arg[0], y1, x2_arg[1], y2, x2);
		}
		else if (x2_arg[1] <= x2 && x2 < x2_arg[2])
		{
			float y1 = Linterp(Matrix_2_2, Length_2_2, x1);
			float y2 = Linterp(Matrix_2_3, Length_2_3, x1);

			return LinterpOnce(x2_arg[1], y1, x2_arg[2], y2, x2);
		}
		else if (x2 == x2_arg[2])
		{
			float y = Linterp(Matrix_2_3, Length_2_3, x1);

			return y;
		}
		else
			return NAN;
	}

	//возвращает с_x_корм при eta_корм = 0.75
	float Cxcor_Con_3(float M, float lambda_cor, InputComplex& x_2, InputComplex& x_1)
	{
		//3.1: lambda_korm = 1, 3.2: lambda_korm = 1.5, 3.3: lambda_korm = 2,
		static unsigned int Length_3_1 = 37; static float Matrix_3_1[][2] = { {0.6f,0.05f}, {0.7f,0.05f}, {0.8f,0.0509589101219369f}, {0.9f,0.0519575158688114f}, {0.95f,0.0533790594915826f}, {1.0f,0.0544574563100137f}, {1.025f,0.0555358531284448f}, {1.05f,0.056028391249616f}, {1.075f,0.0565168435373037f}, {1.1f,0.0569715954632228f}, {1.125f,0.0574131185931121f}, {1.15f,0.0578008487088997f}, {1.175f,0.0581889984921701f}, {1.2f,0.0584966750038655f}, {1.25f,0.0588043515155609f}, {1.3f,0.0593126866218403f}, {1.35f,0.0594999679767853f}, {1.4f,0.0595200338362437f}, {1.5f,0.0591722256056315f}, {1.6f,0.0579020401451876f}, {1.7f,0.0552930928723058f}, {1.8f,0.0521397024605662f}, {1.9f,0.048360909345602f}, {2.0f,0.0442497075486642f}, {2.125f,0.04f}, {2.25f,0.0373672708326386f}, {2.5f,0.0345960359135507f}, {2.75f,0.0301464835021188f}, {3.0f,0.0271977340284701f}, {3.25f,0.024611662378485f}, {3.5f,0.0223614404325713f}, {3.75f,0.02f}, {4.0f,0.0185221724445914f}, {4.25f,0.0170533514738711f}, {4.5f,0.0157370310410944f}, {5.0f,0.0146213692108751f}, {5.5f,0.0129197842611882f} };
		static unsigned int Length_3_2 = 37; static float Matrix_3_2[][2] = { {0.6f,0.0432873985759425f}, {0.7f,0.0420738527325041f}, {0.8f,0.0401475300714077f}, {0.9f,0.0371039402668754f}, {0.95f,0.0360768835044681f}, {1.0f,0.0351198279259461f}, {1.025f,0.0347147518296253f}, {1.05f,0.0343096757333044f}, {1.075f,0.0340890245973152f}, {1.1f,0.0338990082194077f}, {1.125f,0.0338621181776716f}, {1.15f,0.0338243413986992f}, {1.175f,0.0338380888021434f}, {1.2f,0.033884074855266f}, {1.25f,0.0341006086353207f}, {1.3f,0.0341006086353207f}, {1.35f,0.0340483418608247f}, {1.4f,0.0336824744393531f}, {1.5f,0.0329731396426225f}, {1.6f,0.0318158039216409f}, {1.7f,0.03f}, {1.8f,0.0290021449150624f}, {1.9f,0.0272890296304501f}, {2.0f,0.0255055868846465f}, {2.125f,0.0240846076990655f}, {2.25f,0.0226925541586695f}, {2.5f,0.02f}, {2.75f,0.0181560602385742f}, {3.0f,0.0166232517126718f}, {3.25f,0.0149510969571418f}, {3.5f,0.0136969808904943f}, {3.75f,0.0125357623102651f}, {4.0f,0.0116067874460818f}, {4.25f,0.0106468467530924f}, {4.5f,0.01f}, {5.0f,0.00916048697039905f}, {5.5f,0.00843278999345545f} };
		static unsigned int Length_3_3 = 37; static float Matrix_3_3[][2] = { {0.6f,0.0390347907656099f}, {0.7f,0.0363967348383171f}, {0.8f,0.0334009173596076f}, {0.9f,0.030045601783453f}, {0.95f,0.0285614732932753f}, {1.0f,0.0270773448030976f}, {1.025f,0.0264433194330986f}, {1.05f,0.0258092940630996f}, {1.075f,0.0253282027561801f}, {1.1f,0.0248471114492607f}, {1.125f,0.0244193940140394f}, {1.15f,0.0240556248020748f}, {1.175f,0.0236330122010909f}, {1.2f,0.0233031551022854f}, {1.25f,0.0228070824853872f}, {1.3f,0.0223221575677452f}, {1.35f,0.0220824820337382f}, {1.4f,0.0217926418530785f}, {1.5f,0.0215544788275461f}, {1.6f,0.0213457938808864f}, {1.7f,0.0204268312441714f}, {1.8f,0.0198046900190246f}, {1.9f,0.0189744749822574f}, {2.0f,0.0181442599454903f}, {2.125f,0.0169270707819387f}, {2.25f,0.0157309627238771f}, {2.5f,0.0136782731330796f}, {2.75f,0.0120694083186708f}, {3.0f,0.0107101949409806f}, {3.25f,0.00978093681541691f}, {3.5f,0.00887941773837749f}, {3.75f,0.00819981104953238f}, {4.0f,0.00768663865183302f}, {4.25f,0.00722894435118224f}, {4.5f,0.00689607576889076f}, {5.0f,0.00661868528364786f}, {5.5f,0.00663255480791001f} };

		//Значения по комплексу x2
		const float x2_arg[3] = { 1.0f, 1.5f, 2.0f };

		//Входной комплекс x1
		const float x1_min = 0.6f;
		const float x1_max = 5.5f;

		//Входной комплекс x2
		float x2 = lambda_cor;

		float x2_min = x2_arg[0];
		float x2_max = x2_arg[2];

		x_2.Min = x2_min;
		x_2.Value = x2;
		x_2.Max = x2_max;

		//Ограничение по диапазону x2
		if (x2 < x2_arg[0])
			x2 = x2_arg[0];
		else if (x2 > x2_arg[2])
			x2 = x2_arg[2];

		//Координата по оси х графика
		float x1 = M;

		x_1.Min = x1_min;
		x_1.Value = x1;
		x_1.Max = x1_max;

		//Ограничение по диапазону оси x
		if (x1 < x1_min)
			x1 = x1_min;
		else if (x1 > x1_max)
			x1 = x1_max;

		//Вычисление
		if (x2 == x2_arg[0])
		{
			float y = Linterp(Matrix_3_1, Length_3_1, x1);

			return y;
		}
		else if (x2_arg[0] <= x2 && x2 < x2_arg[1])
		{
			float y1 = Linterp(Matrix_3_1, Length_3_1, x1);
			float y2 = Linterp(Matrix_3_2, Length_3_2, x1);

			return LinterpOnce(x2_arg[0], y1, x2_arg[1], y2, x2);
		}
		else if (x2_arg[1] <= x2 && x2 < x2_arg[2])
		{
			float y1 = Linterp(Matrix_3_2, Length_3_2, x1);
			float y2 = Linterp(Matrix_3_3, Length_3_3, x1);

			return LinterpOnce(x2_arg[1], y1, x2_arg[2], y2, x2);
		}
		else if (x2 == x2_arg[2])
		{
			float y = Linterp(Matrix_3_3, Length_3_3, x1);

			return y;
		}
		else
			return NAN;
	}

	float Cxcor_Con(float M, float lambda_cor, float eta_cor, InputComplex& x_3, InputComplex& x_2, InputComplex& x_1)
	{
		//Значения по комплексу x3
		const float x3_arg[4] = { 0.0f, 0.5f, 0.75f, 1.0f };

		//Входной комплекс x3
		float x3 = eta_cor;

		float x3_min = x3_arg[0];
		float x3_max = x3_arg[3];

		x_3.Min = x3_min;
		x_3.Value = x3;
		x_3.Max = x3_max;

		//Ограничение по диапазону x3
		if (x3 < x3_min)
			x3 = x3_min;
		else if (x3 > x3_max)
			x3 = x3_max;

		//Вычисление
		if (x3 == x3_arg[0])
		{
			//Используем 1-ый график
			float y = Cxcor_Con_1(M, lambda_cor, x_2, x_1);

			return y;
		}
		else if (x3_arg[0] <= x3 && x3 < x3_arg[1])
		{
			//Интерполяция между 1-м и 2-м графиком
			float y1 = Cxcor_Con_1(M, lambda_cor, x_2, x_1);
			float y2 = Cxcor_Con_2(M, lambda_cor, x_2, x_1);

			return LinterpOnce(x3_arg[0], y1, x3_arg[1], y2, x3);
		}
		else if (x3_arg[1] <= x3 && x3 < x3_arg[2])
		{
			//Интерполяция между 2-м и 3-м графиком
			float y1 = Cxcor_Con_2(M, lambda_cor, x_2, x_1);
			float y2 = Cxcor_Con_3(M, lambda_cor, x_2, x_1);

			return LinterpOnce(x3_arg[1], y1, x3_arg[2], y2, x3);
		}
		else if (x3_arg[2] <= x3 && x3 <= x3_arg[3])
		{
			//Интерполяция между 2-м и 3-м графиком
			float y1 = Cxcor_Con_3(M, lambda_cor, x_2, x_1);
			float y2 = 0.0f;

			return LinterpOnce(x3_arg[2], y1, x3_arg[3], y2, x3);
		}		
		else
			return NAN;
	}

	ErrorCode* get_Cxcor_Con(float& Result, float M, float lambda_cor, float eta_cor, InputComplex& x_3, InputComplex& x_2, InputComplex& x_1)
	{
		static ErrorCode ErrC;
		// Проверка: некоторые аргументы не должны быть меньше 0		
		if (M < 0.0f)
		{
			ErrC.ArgNumber = 1;
			ErrC.Code = ErrC_NumberMustNotBeNeg;
			return &ErrC;
		}
		if (lambda_cor < 0.0f)
		{
			ErrC.ArgNumber = 2;
			ErrC.Code = ErrC_NumberMustNotBeNeg;
			return &ErrC;
		}
		if (eta_cor < 0.0f)
		{
			ErrC.ArgNumber = 3;
			ErrC.Code = ErrC_NumberMustNotBeNeg;
			return &ErrC;
		}

		// Вызываем функцию интерполяции графика
		Result = Cxcor_Con(M, lambda_cor, eta_cor, x_3, x_2, x_1);
		ErrC.ArgNumber = ErrC_OK;
		ErrC.Code = ErrC_OK;

		return &ErrC;
	}
}