#include "AASM6.h"
#include "Extensions.h"

namespace AASM6
{
	float kM_Con(float M, float lambda_nos, InputComplex& x_2, InputComplex& x_1)
	{
		//1_0: M = 1, 1_1: M = 2, 1_2: M = 3, 1_3: M = 4, 1_4: M = 5
		//unsigned int Length_1_1 = 2; float Matrix_1_1[][2] = { {0.7f,1.0f},{5.0f,1.0f} };
		static unsigned int Length_1_2 = 26; static float Matrix_1_2[][2] = { {0.7f,0.934279831870284f}, {0.8f,0.948905823974755f}, {0.9f,0.961571001851882f}, {1.0f,0.969982321241974f}, {1.1f,0.976219033459308f}, {1.2f,0.981306332646839f}, {1.3f,0.984810391037052f}, {1.4f,0.987714494139514f}, {1.5f,0.989559314131599f}, {1.6f,0.991225815505364f}, {1.7f,0.992532215348886f}, {1.8f,0.993552065910239f}, {2.0f,0.995000485973652f}, {2.2f,0.995340547188321f}, {2.4f,0.995671978953029f}, {2.6f,0.996003200256439f}, {2.8f,0.996332228014078f}, {3.0f,0.996667641774494f}, {3.25f,0.997084186787171f}, {3.5f,0.997500731799848f}, {3.75f,0.997917276812525f}, {4.0f,0.998334055451659f}, {4.25f,0.998750763561417f}, {4.5f,0.999167283285982f}, {4.75f,0.999583456863232f}, {5.0f,1.0f} };
		static unsigned int Length_1_3 = 26; static float Matrix_1_3[][2] = { {0.7f,0.822048394005982f}, {0.8f,0.861389361131574f}, {0.9f,0.89665642800062f}, {1.0f,0.920455376727935f}, {1.1f,0.939274296475583f}, {1.2f,0.951289250501697f}, {1.3f,0.961409914380341f}, {1.4f,0.968840447976836f}, {1.5f,0.973909391272376f}, {1.6f,0.977444527905907f}, {1.7f,0.981454196534629f}, {1.8f,0.98424623370704f}, {2.0f,0.988805464818233f}, {2.2f,0.992037800869837f}, {2.4f,0.993781704496361f}, {2.6f,0.994689260241829f}, {2.8f,0.995277129656927f}, {3.0f,0.995746997235361f}, {3.25f,0.996318819501701f}, {3.5f,0.996884691342337f}, {3.75f,0.997402855532765f}, {4.0f,0.997954055984372f}, {4.25f,0.998462116059947f}, {4.5f,0.999001272839239f}, {4.75f,0.999511854925223f}, {5.0f,1.0f} };
		static unsigned int Length_1_4 = 26; static float Matrix_1_4[][2] = { {0.7f,0.712761942274813f}, {0.8f,0.761189398396585f}, {0.9f,0.804919446200338f}, {1.0f,0.839891234359892f}, {1.1f,0.870154058778532f}, {1.2f,0.895440808367405f}, {1.3f,0.914024631866506f}, {1.4f,0.927894746069303f}, {1.5f,0.939979846807454f}, {1.6f,0.949731459996109f}, {1.7f,0.958612748838724f}, {1.8f,0.966341529071113f}, {2.0f,0.977292415319678f}, {2.2f,0.984715499286826f}, {2.4f,0.989595624854421f}, {2.6f,0.9928588420944f}, {2.8f,0.99412195782915f}, {3.0f,0.994836266537536f}, {3.25f,0.99564473020148f}, {3.5f,0.996336124541276f}, {3.75f,0.997013052882005f}, {4.0f,0.997659886900838f}, {4.25f,0.998266844620029f}, {4.5f,0.998881458067197f}, {4.75f,0.999451514262692f}, {5.0f,1.0f} };
		static unsigned int Length_1_5 = 26; static float Matrix_1_5[][2] = { {0.7f,0.6f}, {0.8f,0.649664174045177f}, {0.9f,0.703932639307961f}, {1.0f,0.75039297576922f}, {1.1f,0.791507490508979f}, {1.2f,0.826689956684407f}, {1.3f,0.855093897773287f}, {1.4f,0.87992411504364f}, {1.5f,0.899790343408314f}, {1.6f,0.914613841777474f}, {1.7f,0.927352553831798f}, {1.8f,0.93775063982945f}, {2.0f,0.954886459730294f}, {2.2f,0.9667934277268f}, {2.4f,0.976540419633879f}, {2.6f,0.984022958875677f}, {2.8f,0.990040839706223f}, {3.0f,0.99400788520662f}, {3.25f,0.995255570211458f}, {3.5f,0.99606728156584f}, {3.75f,0.996759838265196f}, {4.0f,0.997424775547162f}, {4.25f,0.998078203343975f}, {4.5f,0.998753477570833f}, {4.75f,0.999388652060533f}, {5.0f,1.0f} };

		//Значения по комплексу x2
		const float x2_arg[5] = { 1.0f, 2.0f, 3.0f, 4.0f, 5.0f };

		//Входной комплекс x1
		const float x1_min = 0.7f;
		const float x1_max = 5.0f;

		//Входной комплекс x2
		float x2 = M;

		float x2_min = x2_arg[0];
		float x2_max = x2_arg[4];

		x_2.Min = x2_min;
		x_2.Value = x2;
		x_2.Max = x2_max;

		//Ограничение по диапазону x2
		if (x2 < x2_arg[0])
			x2 = x2_arg[0];
		else if (x2 > x2_arg[4])
			x2 = x2_arg[4];

		//Координата по оси х графика
		float x1 = lambda_nos;

		x_1.Min = x1_min;
		x_1.Value = x1;
		x_1.Max = x1_max;

		//Ограничение по диапазону оси x
		if (x1 < x1_min)
			x1 = x1_min;
		else if (x1 > x1_max)
			x1 = x1_max;

		//Вычисление
		if (x2 == x2_arg[0])
		{
			return 1.0f;
		}
		else if (x2_arg[0] <= x2 && x2 < x2_arg[1])
		{
			float y1 = 1.0f;
			float y2 = Linterp(Matrix_1_2, Length_1_2, x1);

			return LinterpOnce(x2_arg[0], y1, x2_arg[1], y2, x2);
		}
		else if (x2_arg[1] <= x2 && x2 < x2_arg[2])
		{
			float y1 = Linterp(Matrix_1_2, Length_1_2, x1);
			float y2 = Linterp(Matrix_1_3, Length_1_3, x1);

			return LinterpOnce(x2_arg[1], y1, x2_arg[2], y2, x2);
		}
		else if (x2_arg[2] <= x2 && x2 < x2_arg[3])
		{
			float y1 = Linterp(Matrix_1_3, Length_1_3, x1);
			float y2 = Linterp(Matrix_1_4, Length_1_4, x1);

			return LinterpOnce(x2_arg[2], y1, x2_arg[3], y2, x2);
		}
		else if (x2_arg[3] <= x2 && x2 < x2_arg[4])
		{
			float y1 = Linterp(Matrix_1_4, Length_1_4, x1);
			float y2 = Linterp(Matrix_1_5, Length_1_5, x1);

			return LinterpOnce(x2_arg[3], y1, x2_arg[4], y2, x2);
		}
		else if (x2 == x2_arg[4])
		{
			float y = Linterp(Matrix_1_5, Length_1_5, x1);

			return y;
		}
		else
			return NAN;
	}

	ErrorCode* get_kM_Con(float& Result, float M, float lambda_nos, InputComplex& x_2, InputComplex& x_1)
	{
		static ErrorCode ErrC;
		// Проверка: некоторые аргументы не должны быть меньше 0		
		if (M < 0.0f)
		{
			ErrC.ArgNumber = 1;
			ErrC.Code = ErrC_NumberMustNotBeNeg;
			return &ErrC;
		}
		if (lambda_nos < 0.0f)
		{
			ErrC.ArgNumber = 2;
			ErrC.Code = ErrC_NumberMustNotBeNeg;
			return &ErrC;
		}		

		// Вызываем функцию интерполяции графика
		Result = kM_Con(M, lambda_nos, x_2, x_1);
		ErrC.ArgNumber = ErrC_OK;
		ErrC.Code = ErrC_OK;

		return &ErrC;
	}
}
