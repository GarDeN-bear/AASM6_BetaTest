#include "AASM6.h"
#include "Extensions.h"

namespace AASM6
{
	float Cyalf_SphCil(float M, float lambda_nos, float lambda_cil, InputComplex& x_2, InputComplex& x_1)
	{
		static unsigned int Length_1_0 = 55; static float Matrix_1_0[][2] = { {-0.4f,0.0347696471896909f}, {-0.35f,0.0348600449095591f}, {-0.3f,0.0349245077670796f}, {-0.25f,0.0350378074338689f}, {-0.2f,0.035138608448094f}, {-0.15f,0.0352297975343676f}, {-0.1375f,0.0352376516053055f}, {-0.125f,0.0352455056762434f}, {-0.1125f,0.0352630739502515f}, {-0.1f,0.0352952042436423f}, {-0.0875f,0.0354010262116456f}, {-0.075f,0.0355399844656966f}, {-0.0625f,0.0356869296284926f}, {-0.05f,0.0358227905849968f}, {-0.0375f,0.0360464904395501f}, {-0.025f,0.0362506970386702f}, {-0.0125f,0.0364643216425822f}, {0.0f,0.0366816257963756f}, {0.0125f,0.0368927065491639f}, {0.025f,0.0371114038010929f}, {0.0375f,0.0373388534396814f}, {0.05f,0.0375568845603041f}, {0.0625f,0.0376698441822518f}, {0.075f,0.0377453246181719f}, {0.0875f,0.0378111869807483f}, {0.1f,0.0378521084222122f}, {0.1125f,0.0378505191289499f}, {0.125f,0.0378476849445093f}, {0.1375f,0.0378248240695473f}, {0.15f,0.0377805206514351f}, {0.1625f,0.0377000205136222f}, {0.175f,0.0375761827703181f}, {0.1875f,0.0374523450270141f}, {0.2f,0.0373285072837101f}, {0.2125f,0.0372059808401392f}, {0.225f,0.0370309924285018f}, {0.2375f,0.0368516639721113f}, {0.25f,0.036650612055606f}, {0.2625f,0.0364437805632147f}, {0.275f,0.0362337991204261f}, {0.2875f,0.0359917427780626f}, {0.3f,0.0357303219283101f}, {0.35f,0.0346070869315922f}, {0.4f,0.0335058894011197f}, {0.45f,0.0325230495232329f}, {0.5f,0.0316020658625393f}, {0.55f,0.0307618732132518f}, {0.6f,0.0299480628252702f}, {0.65f,0.0291177932585334f}, {0.7f,0.0283567325137394f}, {0.75f,0.0275939460834189f}, {0.8f,0.0268311596530983f}, {0.85f,0.0261407064187565f}, {0.9f,0.0254502531844146f}, {1.0f,0.0241450986749286f} };
		static unsigned int Length_1_1 = 55; static float Matrix_1_1[][2] = { {-0.4f,0.0347696471896909f}, {-0.35f,0.0348600449095591f}, {-0.3f,0.0349245077670796f}, {-0.25f,0.0350378074338689f}, {-0.2f,0.035138608448094f}, {-0.15f,0.0352297975343676f}, {-0.1375f,0.0352376516053055f}, {-0.125f,0.0352455056762434f}, {-0.1125f,0.0352630739502515f}, {-0.1f,0.0353636370674629f}, {-0.0875f,0.0355887329149841f}, {-0.075f,0.0359311939626105f}, {-0.0625f,0.0362976774593488f}, {-0.05f,0.0366744556301872f}, {-0.0375f,0.0370747952572566f}, {-0.025f,0.037517278326545f}, {-0.0125f,0.0380140273847058f}, {0.0f,0.0385751238281215f}, {0.0125f,0.0391727205079057f}, {0.025f,0.0398203764836665f}, {0.0375f,0.0405280463018456f}, {0.05f,0.0412917911483061f}, {0.0625f,0.0420041094578669f}, {0.075f,0.0426088518508289f}, {0.0875f,0.0430558694886609f}, {0.1f,0.0434465714443588f}, {0.1125f,0.0436937580781184f}, {0.125f,0.0438762779631326f}, {0.1375f,0.0440092366705076f}, {0.15f,0.044121124234891f}, {0.1625f,0.0441964777845669f}, {0.175f,0.0442277955052037f}, {0.1875f,0.0442319797514953f}, {0.2f,0.0442132553605892f}, {0.2125f,0.044142398951021f}, {0.225f,0.0440231344356018f}, {0.2375f,0.0438820025851307f}, {0.25f,0.043720076965149f}, {0.2625f,0.0435400386598571f}, {0.275f,0.0433494421233563f}, {0.2875f,0.0431779642246626f}, {0.3f,0.043006432238716f}, {0.35f,0.0421256503933854f}, {0.4f,0.0411200737891928f}, {0.45f,0.0401138951941152f}, {0.5f,0.0391427096693105f}, {0.55f,0.0382012634101607f}, {0.6f,0.0372627310601096f}, {0.65f,0.0363464855272556f}, {0.7f,0.0354409059337521f}, {0.75f,0.034520127659786f}, {0.8f,0.033566025429007f}, {0.85f,0.032662205663117f}, {0.9f,0.0317906942420789f}, {1.0f,0.0300188637209135f} };

		//Значения по комплексу x2
		const float x2_min = 0.0f;	
		const float x2_max = 0.5f;

		//Входной комплекс x2
		float x2 = lambda_nos;

		x_2.Min = x2_min;
		x_2.Value = x2;
		x_2.Max = x2_max;

		//Ограничение по диапазону x2
		if (x2 < x2_min)
			x2 = x2_min;
		else if (x2 > x2_max)
			x2 = x2_max;

		//Входной комплекс x1
		const float x1_min = -0.4f;
		const float x1_max = +1.0f;

		//Координата по оси х графика
		float x1;

		if (M >= 1)
			x1 = +sqrt(sqr(M) - 1.0f) / lambda_cil;
		else
			x1 = -sqrt(1.0f - sqr(M)) / lambda_cil;

		x_1.Min = x1_min;
		x_1.Value = x1;
		x_1.Max = x1_max;

		//Ограничение по диапазону оси x
		if (x1 < x1_min)
			x1 = x1_min;
		else if (x1 > x1_max)
			x1 = x1_max;

		//Вычисление
		if (x2 <= x2_min) {
			float y = Linterp(Matrix_1_0, Length_1_0, x1);

			return y * deg;
		}
		else if (x2 < x2_max) {
			float y1 = Linterp(Matrix_1_0, Length_1_0, x1);
			float y2 = Linterp(Matrix_1_1, Length_1_1, x1);

			return LinterpOnce(x2_min, y1, x2_max, y2, x2) * deg;
		}
		else {
			float y = Linterp(Matrix_1_1, Length_1_1, x1);

			return y * deg;
		}
	}

	ErrorCode* get_Cyalf_SphCil(float& Result, float M, float lambda_nos, float lambda_cil, InputComplex& x_2, InputComplex& x_1)
	{		
		static ErrorCode ErrC;
		// Проверка: некоторые аргументы не должны быть меньше 0		
		if (M < 0.0f)
		{
			ErrC.ArgNumber = 1;
			ErrC.Code = ErrC_NumberMustNotBeNeg;
			return &ErrC;
		}
		if (lambda_nos < 0.0f)
		{
			ErrC.ArgNumber = 2;
			ErrC.Code = ErrC_NumberMustNotBeNeg;
			return &ErrC;
		}
		if (lambda_cil < 0.0f)
		{
			ErrC.ArgNumber = 3;
			ErrC.Code = ErrC_NumberMustNotBeNeg;
			return &ErrC;
		}
		
		// Вызываем функцию интерполяции графика
		Result = Cyalf_SphCil(M, lambda_nos, lambda_cil, x_2, x_1);
		ErrC.ArgNumber = ErrC_OK;
		ErrC.Code = ErrC_OK;

		return &ErrC;
	}
}