#include "AASM6.h"
#include "Extensions.h"

namespace AASM6
{
	float Cxdon_Cil(float M, float cc, float Re_f06, float Re_f, float xx_tf, float lambda_f, InputComplex& x_2, InputComplex& x_1)
	{		
		static const unsigned int Length_1_1 = 60; static float Matrix_1_1[][2] = { {0.6f,0.04f}, {0.7f,0.0418951392259252f}, {0.799999999996579f,0.0473663072585405f}, {0.824999999966768f,0.0497677500526791f}, {0.85f,0.0528740752657931f}, {0.875f,0.0570001987958913f}, {0.899999999860505f,0.0627397193134635f}, {0.925f,0.0714467555684619f}, {0.95f,0.0876358308281903f}, {0.975000000000273f,0.142872060503949f}, {0.9875f,0.173052551465073f}, {1.0f,0.192005972262085f}, {1.0125f,0.20630888420689f}, {1.025f,0.218096632680485f}, {1.05f,0.221208264750203f}, {1.075f,0.222069947477202f}, {1.1f,0.221973394965482f}, {1.125f,0.221050165960189f}, {1.15f,0.219099607842348f}, {1.2f,0.21421906040899f}, {1.3f,0.205620983712938f}, {1.4f,0.197099898968172f}, {1.5f,0.188666579135368f}, {1.54999999996609f,0.184617156402146f}, {1.6f,0.180688035683899f}, {1.650000000001f,0.176867300314991f}, {1.7f,0.173201503040731f}, {1.8f,0.166353253517012f}, {1.9f,0.159704467571653f}, {2.0f,0.153155413415475f}, {2.1f,0.146340407821483f}, {2.2f,0.140190280822026f}, {2.3f,0.133541494876668f}, {2.4f,0.127191904298851f}, {2.5f,0.121440704456116f}, {2.6f,0.11652060285655f}, {2.7f,0.110935622662449f}, {2.8f,0.10594903320343f}, {2.9f,0.101261639111953f}, {3.0f,0.0969399282474696f}, {3.1f,0.0926182173829867f}, {3.2f,0.0886621897454985f}, {3.3f,0.0850053574755512f}, {3.4f,0.0817425229040823f}, {3.5f,0.078323327600466f}, {3.6f,0.0754311057142351f}, {3.7f,0.0724391520388238f}, {3.8f,0.070012345168768f}, {3.9f,0.0674525625798049f}, {4.0f,0.0650922435692027f}, {4.1f,0.0628316563477809f}, {4.2f,0.060903508423627f}, {4.3f,0.0588756287102926f}, {4.4f,0.0569142368564119f}, {4.5f,0.0552187964403455f}, {4.6f,0.0534236242350987f}, {4.7f,0.0518611595379396f}, {4.8f,0.0504316705596874f}, {4.9f,0.048902449792255f}, {5.0f,0.0476391804626369f} };
		static unsigned int Length_1_2 = 60; static float Matrix_1_2[][2] = { {0.6f,0.04f}, {0.7f,0.0418951392259252f}, {0.799999999999993f,0.0513911599621044f}, {0.824999999999993f,0.0561689638010198f}, {0.85f,0.0626284143596585f}, {0.874999999999993f,0.0716033777341374f}, {0.9f,0.0847372356748926f}, {0.924999999999902f,0.105942841535533f}, {0.95f,0.147025531979295f}, {0.975000000002868f,0.219518612160236f}, {0.9875f,0.251339935759843f}, {1.0f,0.27705868241206f}, {1.0125f,0.280050638190955f}, {1.025f,0.281418629145729f}, {1.05f,0.282458426130653f}, {1.075f,0.282446007035176f}, {1.1f,0.28133312160804f}, {1.125f,0.279655f}, {1.15f,0.278077729648241f}, {1.2f,0.275461949748744f}, {1.3f,0.271212731658292f}, {1.4f,0.268102527638191f}, {1.5f,0.266168715577889f}, {1.55f,0.265840744723618f}, {1.6f,0.265134903517588f}, {1.65f,0.261712506532663f}, {1.7f,0.252640726633166f}, {1.8f,0.232497384924623f}, {1.9f,0.213743019095477f}, {2.0f,0.196389689447236f}, {2.1f,0.181509704522613f}, {2.2f,0.167786610050251f}, {2.3f,0.155539545728643f}, {2.4f,0.145087654271357f}, {2.5f,0.135912327638191f}, {2.6f,0.128252926633166f}, {2.7f,0.121750413065327f}, {2.8f,0.115583486432161f}, {2.9f,0.110601110552764f}, {3.0f,0.105281209045226f}, {3.1f,0.10043663718593f}, {3.2f,0.0959175547738693f}, {3.3f,0.0914542512562814f}, {3.4f,0.0872638211055276f}, {3.5f,0.0836470060301508f}, {3.6f,0.0804303487437186f}, {3.7f,0.0774060743718593f}, {3.8f,0.0745434020100502f}, {3.9f,0.0718053939698493f}, {4.0f,0.0692289909547739f}, {4.1f,0.0664694371859297f}, {4.2f,0.0638337788944724f}, {4.3f,0.0612250512562814f}, {4.4f,0.0587373005025126f}, {4.5f,0.0564527809045226f}, {4.6f,0.0542474040201005f}, {4.7f,0.0523110351758794f}, {4.8f,0.0506784412060302f}, {4.9f,0.0490824894472362f}, {5.0f,0.0476391819095477f} };
		const float x2_min = 0.0f;
		const float x2_max = 0.1f;

		//Входной комплекс x2
		float x2 = cc;

		x_2.Min = x2_min;
		x_2.Value = x2;
		x_2.Max = x2_max;

		//Ограничение по диапазону x2
		if (x2 < x2_min)
			x2 = x2_min;
		else if (x2 > x2_max)
			x2 = x2_max;

		//Входной комплекс x1
		const float x1_min = 0.0f;
		const float x1_max = 5.0f;

		//Координата по оси х графика
		float x1;
		x1 = M;

		x_1.Min = x1_min;
		x_1.Value = x1;
		x_1.Max = x1_max;

		//Ограничение по диапазону оси x
		if (x1 < x1_min)
			x1 = x1_min;
		else if (x1 > x1_max)
			x1 = x1_max;

		float y = 0;
		//Вычисление
		if (M <= 0.6f)
		{	//дозвуковая область, поэтому расчёт по формуле
			InputComplex x_x_2, x_x_1;
			float Cf_M0, Sigma_M, Cf;
			ErrorCode* ErrC = get_Cf_M0(Cf_M0, Re_f, xx_tf, x_x_2, x_x_1);
			ErrC = get_Sigma_M(Sigma_M, M, xx_tf, x_x_2, x_x_1);
			Cf = Cf_M0 * Sigma_M;

			y = 0.0155f / sqrt(lambda_f * Cf);
		}
		else if (M > 0.6f && M < Matrix_1_1[13][0])
		{
			//область перехода с формулы на график, поэтому необходим расчёт по формуле и перемасштабирование кривой под это значение
			InputComplex x_x_2, x_x_1;
			float Cf_M0, Sigma_M, Cf;
			ErrorCode* ErrC = get_Cf_M0(Cf_M0, Re_f06, xx_tf, x_x_2, x_x_1);
			ErrC = get_Sigma_M(Sigma_M, 0.6f, xx_tf, x_x_2, x_x_1);
			Cf = Cf_M0 * Sigma_M;

			float y_subs = 0.0155f / sqrt(lambda_f * Cf);
		
			if (x2 == x2_min)
			{
				//Перемасштабируем первую кривую до точки i=13
				const int Length_1_1S = 14;
				float yv = Matrix_1_1[Length_1_1S - 1][1]; // Ордината конца масштабируемого отрезка (должна остаться на месте)
				float yn = Matrix_1_1[0][1]; // Ордината начала мастабируемого отрезка (должна совпасть с формулой при М=0.6)
				float H_otr = yv - yn; // Высота мастабируемого отрезка
				float d_yn = yn - y_subs; // На сколько надо растянуть (если d_yn > 0) или сжать (если d_yn < 0) по вертикали мастабируемого отрезка
				float Mstb = (H_otr + d_yn) / H_otr; //Коэффициент масштабирования
				float Matrix_1_1S[Length_1_1S][2]; //Новая матрица первой кривой
				for (int i = 0; i < Length_1_1S; i++)
				{
					Matrix_1_1S[i][0] = Matrix_1_1[i][0]; //Абсцисса остаётся такой же как в исходной матрице
					Matrix_1_1S[i][1] = ((Matrix_1_1[i][1] - yv) * Mstb) + yv; //Оридината масштабируется
				}

				y = Linterp(Matrix_1_1S, Length_1_1S, x1);
			}
			else if (x2_min <= x2 && x2 < x2_max)
			{
				//Перемасштабируем первую кривую до точки i=13
				const int Length_1_1S = 14;
				float yv = Matrix_1_1[Length_1_1S - 1][1]; // Ордината конца масштабируемого отрезка (должна остаться на месте)
				float yn = Matrix_1_1[0][1]; // Ордината начала мастабируемого отрезка (должна совпасть с формулой при М=0.6)
				float H_otr = yv - yn; // Высота мастабируемого отрезка
				float d_yn = yn - y_subs; // На сколько надо растянуть (если d_yn > 0) или сжать (если d_yn < 0) по вертикали мастабируемого отрезка
				float Mstb = (H_otr + d_yn) / H_otr; //Коэффициент масштабирования
				float Matrix_1_1S[Length_1_1S][2]; //Новая матрица первой кривой
				for (int i = 0; i < Length_1_1S; i++)
				{
					Matrix_1_1S[i][0] = Matrix_1_1[i][0]; //Абсцисса остаётся такой же как в исходной матрице
					Matrix_1_1S[i][1] = ((Matrix_1_1[i][1] - yv) * Mstb) + yv; //Оридината масштабируется
				}

				//Перемасштабируем вторую кривую до точки i=11 и прибавляем ещё неизменённую 12 и 13 точки
				const int Length_1_2S = 14;
				float yv2 = Matrix_1_2[Length_1_2S - 1][1]; // Ордината конца масштабируемого отрезка (должна остаться на месте)
				float yn2 = Matrix_1_2[0][1]; // Ордината начала мастабируемого отрезка (должна совпасть с формулой при М=0.6)
				float H_otr2 = yv2 - yn2; // Высота мастабируемого отрезка
				float d_yn2 = yn2 - y_subs; // На сколько надо растянуть (если d_yn > 0) или сжать (если d_yn < 0) по вертикали мастабируемого отрезка
				float Mstb2 = (H_otr2 + d_yn2) / H_otr2; //Коэффициент масштабирования
				float Matrix_1_2S[Length_1_2S + 2][2]; //Новая матрица первой кривой
				for (int i = 0; i < Length_1_2S; i++)
				{
					Matrix_1_2S[i][0] = Matrix_1_2[i][0]; //Абсцисса остаётся такой же как в исходной матрице
					Matrix_1_2S[i][1] = ((Matrix_1_2[i][1] - yv2) * Mstb2) + yv2; //Оридината масштабируется
				}
				Matrix_1_2S[Length_1_2S][0] = Matrix_1_2[Length_1_2S][0];
				Matrix_1_2S[Length_1_2S][1] = Matrix_1_2[Length_1_2S][1];
				Matrix_1_2S[Length_1_2S + 1][0] = Matrix_1_2[Length_1_2S + 1][0];
				Matrix_1_2S[Length_1_2S + 1][1] = Matrix_1_2[Length_1_2S + 1][1];

				float y1 = Linterp(Matrix_1_1S, Length_1_1S, x1);
				float y2 = Linterp(Matrix_1_2S, Length_1_2S, x1);

				y = LinterpOnce(x2_min, y1, x2_max, y2, x2);
			}
			else if (x2 == x2_max)
			{
				//Перемасштабируем вторую кривую до точки i=11 и прибалвяем ещё неизменённую 12 и 13 точки
				const int Length_1_2S = 14;
				float yv2 = Matrix_1_2[Length_1_2S - 1][1]; // Ордината конца масштабируемого отрезка (должна остаться на месте)
				float yn2 = Matrix_1_2[0][1]; // Ордината начала мастабируемого отрезка (должна совпасть с формулой при М=0.6)
				float H_otr2 = yv2 - yn2; // Высота мастабируемого отрезка
				float d_yn2 = yn2 - y_subs; // На сколько надо растянуть (если d_yn > 0) или сжать (если d_yn < 0) по вертикали мастабируемого отрезка
				float Mstb2 = (H_otr2 + d_yn2) / H_otr2; //Коэффициент масштабирования
				float Matrix_1_2S[Length_1_2S + 2][2]; //Новая матрица первой кривой
				for (int i = 0; i < Length_1_2S; i++)
				{
					Matrix_1_2S[i][0] = Matrix_1_2[i][0]; //Абсцисса остаётся такой же как в исходной матрице
					Matrix_1_2S[i][1] = ((Matrix_1_2[i][1] - yv2) * Mstb2) + yv2; //Оридината масштабируется
				}
				Matrix_1_2S[Length_1_2S][0] = Matrix_1_2[Length_1_2S][0];
				Matrix_1_2S[Length_1_2S][1] = Matrix_1_2[Length_1_2S][1];
				Matrix_1_2S[Length_1_2S + 1][0] = Matrix_1_2[Length_1_2S + 1][0];
				Matrix_1_2S[Length_1_2S + 1][1] = Matrix_1_2[Length_1_2S + 1][1];

				y = Linterp(Matrix_1_2S, Length_1_2S, x1);
			}
		}
		else if (M >= Matrix_1_1[13][0])
		{
			if (x2 == x2_min)
			{
				y = Linterp(Matrix_1_1, Length_1_1, x1);
			}
			else if (x2_min <= x2 && x2 < x2_max)
			{
				float y1 = Linterp(Matrix_1_1, Length_1_1, x1);
				float y2 = Linterp(Matrix_1_2, Length_1_2, x1);

				y = LinterpOnce(x2_min, y1, x2_max, y2, x2);
			}
			else if (x2 == x2_max)
			{
				y = Linterp(Matrix_1_2, Length_1_2, x1);
			}
		}

		return y;
	}

	ErrorCode* get_Cxdon_Cil(float& Result, float M, float cc, float Re_f06, float Re_f, float xx_tf, float lambda_f, InputComplex& x_2, InputComplex& x_1)
	{
		static ErrorCode ErrC;
		// Проверка: некоторые аргументы не должны быть меньше 0		
		if (M < 0.0f)
		{
			ErrC.ArgNumber = 1;
			ErrC.Code = ErrC_NumberMustNotBeNeg;
			return &ErrC;
		}
		if (cc < 0.0f)
		{
			ErrC.ArgNumber = 2;
			ErrC.Code = ErrC_NumberMustNotBeNeg;
			return &ErrC;
		}
		if (Re_f06 < 0.0f)
		{
			ErrC.ArgNumber = 3;
			ErrC.Code = ErrC_NumberMustNotBeNeg;
			return &ErrC;
		}
		if (Re_f < 0.0f)
		{
			ErrC.ArgNumber = 4;
			ErrC.Code = ErrC_NumberMustNotBeNeg;
			return &ErrC;
		}
		if (xx_tf < 0.0f)
		{
			ErrC.ArgNumber = 5;
			ErrC.Code = ErrC_NumberMustNotBeNeg;
			return &ErrC;
		}
		if (lambda_f < 0.0f)
		{
			ErrC.ArgNumber = 6;
			ErrC.Code = ErrC_NumberMustNotBeNeg;
			return &ErrC;
		}

		// Проверка: некоторые аргументы не должны быть больше 1		
		if (xx_tf > 1.0f)
		{
			ErrC.ArgNumber = 5;
			ErrC.Code = ErrC_ArgMustNotBeGT1;
			return &ErrC;
		}

		// Вызываем функцию интерполяции графика
		Result = Cxdon_Cil(M, cc, Re_f06, Re_f, xx_tf, lambda_f, x_2, x_1);
		ErrC.ArgNumber = ErrC_OK;
		ErrC.Code = ErrC_OK;

		return &ErrC;
	}
}