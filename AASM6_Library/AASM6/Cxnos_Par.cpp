#include "AASM6.h"
#include "Extensions.h"

namespace AASM6
{
	float Cxnos_Par(float M, float lambda_nos, InputComplex& x_2, InputComplex& x_1)
	{
		static unsigned int Length_1_1 = 25; static float Matrix_1_1[][2] = { {0.6f,0.000416697573645097f}, {0.7f,0.00361694504660786f}, {0.75f,0.0060147730917991f}, {0.8f,0.00999072843216862f}, {0.85f,0.0153898523475063f}, {0.9f,0.0241885402953008f}, {0.95f,0.0389440660106554f}, {1.0f,0.0886536816839714f}, {1.05f,0.142231235939023f}, {1.1f,0.168774488326712f}, {1.15f,0.184342114301098f}, {1.2f,0.194739901363244f}, {1.3f,0.206893172959105f}, {1.4f,0.211417994166645f}, {1.5f,0.211587398666586f}, {1.6f,0.209713443945744f}, {1.8f,0.204951341839404f}, {2.0f,0.198806832396044f}, {2.5f,0.189834356264414f}, {3.0f,0.181924319811952f}, {3.5f,0.174182282055616f}, {4.0f,0.168295587367205f}, {4.5f,0.164190732351023f}, {5.0f,0.160605106357345f}, {5.5f,0.157583592226702f} };
		static unsigned int Length_1_2 = 25; static float Matrix_1_2[][2] = { {0.6f,-0.00471479267657601f}, {0.7f,-0.00182618018228176f}, {0.75f,0.000941431861780032f}, {0.8f,0.00402649555922298f}, {0.85f,0.00915559928581744f}, {0.9f,0.0169851556114768f}, {0.95f,0.0302654165261955f}, {1.0f,0.0689040146352592f}, {1.05f,0.109446416390234f}, {1.1f,0.132135993714667f}, {1.15f,0.143126669474038f}, {1.2f,0.148601569133011f}, {1.3f,0.152790909942986f}, {1.4f,0.153084264157337f}, {1.5f,0.151222101236596f}, {1.6f,0.149367298652558f}, {1.8f,0.145059185158862f}, {2.0f,0.14037155188063f}, {2.5f,0.133937396461535f}, {3.0f,0.127993898804022f}, {3.5f,0.12273140706601f}, {4.0f,0.117768156146749f}, {4.5f,0.114191358376816f}, {5.0f,0.111640976426023f}, {5.5f,0.110001380557799f} };
		static unsigned int Length_1_3 = 25; static float Matrix_1_3[][2] = { {0.6f,-0.0106393925139861f}, {0.7f,-0.0077765543888183f}, {0.75f,-0.00495840354940447f}, {0.8f,-0.00186809249650175f}, {0.85f,0.00282330251750993f}, {0.9f,0.00936569286091841f}, {0.95f,0.0220134629963078f}, {1.0f,0.0495866371826239f}, {1.05f,0.0934450301628719f}, {1.1f,0.104283276142101f}, {1.15f,0.109114000472709f}, {1.2f,0.111311992753679f}, {1.3f,0.11155299746193f}, {1.4f,0.109867230882738f}, {1.5f,0.108351715783422f}, {1.6f,0.106751074931634f}, {1.8f,0.103656565394647f}, {2.0f,0.0997978279223013f}, {2.5f,0.0943071412131451f}, {3.0f,0.0905005648572471f}, {3.5f,0.0870026985310969f}, {4.0f,0.0845002050734193f}, {4.5f,0.0823764516445286f}, {5.0f,0.080998766366021f}, {5.5f,0.0797988479183845f} };
		static unsigned int Length_1_4 = 25; static float Matrix_1_4[][2] = { {0.6f,-0.0174705157912432f}, {0.7f,-0.0154446598539487f}, {0.75f,-0.0137351424620997f}, {0.8f,-0.0109876294362045f}, {0.85f,-0.00698314987104269f}, {0.9f,-0.00074574397586488f}, {0.95f,0.0114546493955723f}, {1.0f,0.0288634584943397f}, {1.05f,0.0576058312355609f}, {1.1f,0.0641535383017428f}, {1.15f,0.0654084821252139f}, {1.2f,0.0652030545020766f}, {1.3f,0.0645834662834524f}, {1.4f,0.0641200126664805f}, {1.5f,0.0632454668676308f}, {1.6f,0.062836586374971f}, {1.8f,0.0610848125075558f}, {2.0f,0.059713296982616f}, {2.5f,0.0571156932290538f}, {3.0f,0.0545595914943301f}, {3.5f,0.0525339224152446f}, {4.0f,0.0504611380805715f}, {4.5f,0.0490405658834267f}, {5.0f,0.047583083303627f}, {5.5f,0.0469025269914012f} };
		static unsigned int Length_1_5 = 25; static float Matrix_1_5[][2] = { {0.6f,-0.02605511662262f}, {0.7f,-0.0241771582074361f}, {0.75f,-0.0221447509708218f}, {0.8f,-0.0199019108189958f}, {0.85f,-0.0158455456398498f}, {0.9f,-0.0100807780851672f}, {0.95f,-0.000332603890235126f}, {1.0f,0.0136478294164866f}, {1.05f,0.036968013895781f}, {1.1f,0.0418588717671661f}, {1.15f,0.042739572097139f}, {1.2f,0.0426271388088997f}, {1.3f,0.0422332978467943f}, {1.4f,0.0418369012207096f}, {1.5f,0.0414929108730073f}, {1.6f,0.0410819858390553f}, {1.8f,0.0408702321697533f}, {2.0f,0.0397226476498968f}, {2.5f,0.0386220964995403f}, {3.0f,0.0376591976656449f}, {3.5f,0.0364628154195251f}, {4.0f,0.0350097029975994f}, {4.5f,0.0343054372638143f}, {5.0f,0.0331549032482272f}, {5.5f,0.032114545083241f} };

		//Значения по комплексу x2
		const float x2_min = 2.0f;
		const float x2_2 = 2.5f;
		const float x2_3 = 3.0f;
		const float x2_4 = 4.0f;
		const float x2_max = 5.0f;

		//Входной комплекс x2
		float x2 = lambda_nos;

		x_2.Min = x2_min;
		x_2.Value = x2;
		x_2.Max = x2_max;

		//Входной комплекс x1
		const float x1_min = 0.6f;
		const float x1_max = 5.5f;

		//Координата по оси х графика
		float x1 = M;

		x_1.Min = x1_min;
		x_1.Value = x1;
		x_1.Max = x1_max;

		//Ограничение по диапазону оси x
		if (x1 < x1_min)
			x1 = x1_min;
		else if (x1 > x1_max)
			x1 = x1_max;

		//Ограничение по диапазону оси y
		if (x2 < x2_min)
			x2 = x2_min;
		else if (x2 > x2_max)
			x2 = x2_max;

		//Вычисление
		if (x2 == x2_min)
		{
			//Используем кривую 1
			float y = Linterp(Matrix_1_1, Length_1_1, x1);

			return y;
		}
		else if (x2_min <= x2 && x2 < x2_2)
		{
			//Интерполяция между кривыми 1 и 2		
			float y1 = Linterp(Matrix_1_1, Length_1_1, x1);
			float y2 = Linterp(Matrix_1_2, Length_1_2, x1);

			return LinterpOnce(x2_min, y1, x2_2, y2, x2);
		}
		else if (x2_2 <= x2 && x2 < x2_3)
		{
			//Интерполяция между кривыми 2 и 3		
			float y1 = Linterp(Matrix_1_2, Length_1_2, x1);
			float y2 = Linterp(Matrix_1_3, Length_1_3, x1);

			return LinterpOnce(x2_2, y1, x2_3, y2, x2);
		}
		else if (x2_3 <= x2 && x2 < x2_4)
		{
			//Интерполяция между кривыми 3 и 4			
			float y1 = Linterp(Matrix_1_3, Length_1_3, x1);
			float y2 = Linterp(Matrix_1_4, Length_1_4, x1);

			return LinterpOnce(x2_3, y1, x2_4, y2, x2);
		}
		else if (x2_4 <= x2 && x2 < x2_max)
		{
			//Интерполяция между кривыми 4 и 5		
			float y1 = Linterp(Matrix_1_4, Length_1_4, x1);
			float y2 = Linterp(Matrix_1_5, Length_1_5, x1);

			return LinterpOnce(x2_4, y1, x2_max, y2, x2);
		}
		else if (x2 == x2_max)
		{
			//Используем кривую 5		
			float y = Linterp(Matrix_1_5, Length_1_5, x1);

			return y;
		}
		else
			return NAN;
	}

	ErrorCode* get_Cxnos_Par(float& Result, float M, float lambda_nos, InputComplex& x_2, InputComplex& x_1)
	{
		static ErrorCode ErrC;
		// Проверка: некоторые аргументы не должны быть меньше 0		
		if (M < 0.0f)
		{
			ErrC.ArgNumber = 1;
			ErrC.Code = ErrC_NumberMustNotBeNeg;
			return &ErrC;
		}
		if (lambda_nos < 0.0f)
		{
			ErrC.ArgNumber = 2;
			ErrC.Code = ErrC_NumberMustNotBeNeg;
			return &ErrC;
		}

		// Вызываем функцию интерполяции графика
		Result = Cxnos_Par(M, lambda_nos, x_2, x_1);
		ErrC.ArgNumber = ErrC_OK;
		ErrC.Code = ErrC_OK;

		return &ErrC;
	}
}